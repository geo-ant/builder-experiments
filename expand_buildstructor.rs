#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use bon::Builder as BonBuilder;
use buildstructor::Builder as Buildstructor;
use derive_builder::Builder as DeriveBuilder;
use std::{
    fmt::{Debug, Display},
    marker::PhantomData, str::FromStr,
};
use typed_builder::TypedBuilder;
struct Pod<'a, S, T: ?Sized>
where
    S: std::fmt::Display,
    T: std::fmt::Debug + MyTrait,
{
    first: S,
    second: &'a T,
    third: f32,
    forth: T::AssocType,
}
struct Simple<'a, T> {
    field: &'a T,
}
impl<'a, T: 'a> Simple<'a, T> {
    fn new(field: &'a T) -> Self {
        Self { field }
    }
}
impl<'a, T: 'a> Simple<'a, T> {
    fn builder() -> NewSimpleBuilder<'a, T> {
        __simple_new_builder::new()
    }
}
///Autogenerated by buildstructor
#[allow(type_alias_bounds)]
type NewSimpleBuilder<'a, T: 'a> = __simple_new_builder::__SimpleBuilder<
    'a,
    (__simple_new_builder::__Required<&'a T>,),
    T,
>;
mod __simple_new_builder {
    use super::*;
    #[inline(always)]
    pub(super) fn new<'a, T: 'a>() -> __SimpleBuilder<
        'a,
        (__simple_new_builder::__Required<&'a T>,),
        T,
    > {
        __SimpleBuilder {
            fields: (__required(),),
            _phantom: core::default::Default::default(),
        }
    }
    pub(super) struct __Required<T> {
        _uninit: std::mem::MaybeUninit<T>,
    }
    pub(super) struct __Optional<T> {
        lazy: Option<T>,
    }
    pub(super) struct __Set<T> {
        value: T,
    }
    #[inline(always)]
    fn __set<T>(value: T) -> __Set<T> {
        __Set { value }
    }
    #[inline(always)]
    fn __required<T>() -> __Required<T> {
        __Required::<T> {
            _uninit: std::mem::MaybeUninit::uninit(),
        }
    }
    #[inline(always)]
    fn __optional<T>() -> __Optional<T> {
        __Optional::<T> { lazy: None }
    }
    impl<T: Default> From<__Optional<T>> for __Set<T> {
        #[inline(always)]
        fn from(o: __Optional<T>) -> Self {
            __Set {
                value: o.lazy.unwrap_or_default(),
            }
        }
    }
    pub(super) struct __SimpleBuilder<'a, __P, T> {
        fields: __P,
        _phantom: core::marker::PhantomData<(&'a (), T)>,
    }
    impl<'a, T: 'a> __SimpleBuilder<'a, (__Required<&'a T>,), T> {
        #[inline(always)]
        pub(super) fn field(
            self,
            field: &'a T,
        ) -> __SimpleBuilder<'a, (__Set<&'a T>,), T> {
            let field = field;
            __SimpleBuilder {
                fields: (__set(field),),
                _phantom: core::default::Default::default(),
            }
        }
    }
    impl<'a, T: 'a, __P0: Into<__Set<&'a T>>> __SimpleBuilder<'a, (__P0,), T> {
        #[inline(always)]
        pub(super) fn build(self) -> Simple<'a, T> {
            Simple::new(self.fields.0.into().value)
        }
    }
}
/// dummy trait for enforcing more complicated relationships
trait MyTrait {
    type AssocType: Clone;
}
impl MyTrait for f32 {
    type AssocType = i32;
}
impl MyTrait for i32 {
    type AssocType = f32;
}
impl MyTrait for str {
    type AssocType = usize;
}
pub struct Assigned<T: ?Sized>(T);
pub struct Empty;
#[automatically_derived]
impl ::core::default::Default for Empty {
    #[inline]
    fn default() -> Empty {
        Empty {}
    }
}
pub struct Placeholder<T>(PhantomData<T>);
impl<T> Default for Placeholder<T> {
    fn default() -> Self {
        Self(Default::default())
    }
}
impl<T> Assignable<T> for Placeholder<T> {
    fn assign(self, t: T) -> Assigned<T> {
        Assigned(t)
    }
}
pub struct WithDefault<T>(T);
trait AssignedOrDefault {
    type ValueType: ?Sized;
    fn value_or_default(self) -> Self::ValueType;
}
trait Assignable<T> {
    fn assign(self, t: T) -> Assigned<T>;
}
impl<T> Assignable<T> for Empty {
    fn assign(self, t: T) -> Assigned<T> {
        Assigned(t)
    }
}
impl<T> Assignable<T> for WithDefault<T> {
    fn assign(self, t: T) -> Assigned<T> {
        Assigned(t)
    }
}
impl<T> AssignedOrDefault for Assigned<T> {
    type ValueType = T;
    fn value_or_default(self) -> Self::ValueType {
        self.0
    }
}
impl<T> AssignedOrDefault for WithDefault<T> {
    type ValueType = T;
    fn value_or_default(self) -> Self::ValueType {
        self.0
    }
}
struct PodBuilder2<State> {
    state: State,
}
impl PodBuilder2<(Empty, Empty, WithDefault<f32>, Empty)> {
    pub fn new() -> Self {
        Self {
            state: (
                Empty::default(),
                Empty::default(),
                WithDefault(Default::default()),
                Empty::default(),
            ),
        }
    }
}
impl<U, V, W, X> PodBuilder2<(U, V, W, X)> {
    pub fn first<S: std::fmt::Display>(
        self,
        first: S,
    ) -> PodBuilder2<(Assigned<S>, V, W, X)>
    where
        U: Assignable<S>,
    {
        let state = (
            self.state.0.assign(first),
            self.state.1,
            self.state.2,
            self.state.3,
        );
        PodBuilder2 { state }
    }
    pub fn second<'a, T>(self, second: &'a T) -> PodBuilder2<(U, Assigned<&'a T>, W, X)>
    where
        V: Assignable<&'a T>,
        T: std::fmt::Debug + MyTrait + ?Sized,
    {
        let state = (
            self.state.0,
            self.state.1.assign(second),
            self.state.2,
            self.state.3,
        );
        PodBuilder2 { state }
    }
    pub fn third(self, third: f32) -> PodBuilder2<(U, V, Assigned<f32>, X)>
    where
        W: Assignable<f32>,
    {
        let state = (
            self.state.0,
            self.state.1,
            self.state.2.assign(third),
            self.state.3,
        );
        PodBuilder2 { state }
    }
}
impl<
    'a,
    T: ?Sized + std::fmt::Debug + MyTrait,
    U,
    W,
    X,
> PodBuilder2<(U, Assigned<&'a T>, W, X)> {
    pub fn forth(
        self,
        forth: T::AssocType,
    ) -> PodBuilder2<(U, Assigned<&'a T>, W, Assigned<T::AssocType>)>
    where
        X: Assignable<T::AssocType>,
    {
        let state = (
            self.state.0,
            self.state.1,
            self.state.2,
            self.state.3.assign(forth),
        );
        PodBuilder2 { state }
    }
}
impl<'a, S, T, U, V, W, X> PodBuilder2<(U, V, W, X)>
where
    U: AssignedOrDefault<ValueType = S>,
    V: AssignedOrDefault<ValueType = &'a T>,
    W: AssignedOrDefault<ValueType = f32>,
    X: AssignedOrDefault<ValueType = T::AssocType>,
    T: std::fmt::Debug + 'a + MyTrait + ?Sized,
    S: std::fmt::Display,
{
    pub fn build(self) -> Pod<'a, S, T> {
        Pod {
            first: self.state.0.value_or_default(),
            second: self.state.1.value_or_default(),
            third: self.state.2.value_or_default(),
            forth: self.state.3.value_or_default(),
        }
    }
}
fn main() {
    let stemcell = PodBuilder2::new().first("hi").third(1337.);
    let arg_count = std::env::args().count();
    if arg_count > 3 {
        let pod = stemcell.second(&1i32).forth(1f32);
    } else {
        let pod = stemcell.second("string").forth(1).build();
    }
}
